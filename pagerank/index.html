<!-- Most of the following code is the courtesy of http://www.d3noob.org/2013/03/d3js-force-directed-graph-example-basic.html -->
<!DOCTYPE html>
<meta charset="utf-8">
<link rel="stylesheet" type="text/css" href="style.css"/>
<title>Webpage significance based on a underlying graph of web </title>
<!-- Source of all magic - D3.js Library -->
<script type="text/javascript" src="d3.v3.js"></script>
<script src="jquery.min.js"></script>
<body>
<h1>Pagerank Visualization</h1>
<p style="margin-top: 1px;"><img width="16" style="margin: 1px 10px" src="http://www.jiuzhang.com/static/img/logo-square.png" alt="">Power by 九章算法</p>
<script>
    //Holder to store all nodes in given input file


    var inputLinksFromFile = [];
    var nodesCollection, linksCollection;
    //We will use this for scaling function - This is the maximum value of radius for given node
    var maximumRadiusValue = 50;
    //What is the radius of nodes having minimum significance
    var minimumRadiusValue = 3;
    //Thi is predefined set of color set
    var color = d3.scale.category20();
    var numberOfNodesOptions = [];
    var maximumNumberOfLinksFromFile = 0;
    //Number of links to display at the time
    var numberOfLinksToDisplay = 10;
    //Maximum dimension to fit animation in - We will very this value based on a total number of visible links
    var width = 1500, height = 430;
    var defaultAnimationDuration = 2000;
    var isDrawingWithSingleView = true;
    var SVGElementSequenceNumber = 1;
    //Scale is used to downgrade given range of radius to desirable value
    var radiusScale;
    var inputFileName = "data/result.csv";


    //At the top of page we have instructions view and option selector to change number of visible links on screen
    //configureOptionsAndInstructionsView();
    //Perform actual configuration and display of nodes on screen
    loadAndDisplayPageRankNodesWithValue(numberOfLinksToDisplay, loadDefaultValuesInOptions, configureOptionsAndInstructionsView);
    //Load all nodes values from input file

    //Source : http://james.padolsey.com/javascript/deep-copying-of-objects-and-arrays/
    //Deep cloning of an object as the original array is mutated while creating force layout
    function clone(obj) {
        if (Object.prototype.toString.call(obj) === '[object Array]') {
            var out = [], i = 0, len = obj.length;
            for (; i < len; i++) {
                out[i] = arguments.callee(obj[i]);
            }
            return out;
        }
        if (typeof obj === 'object') {
            var out = {}, i;
            for (i in obj) {
                out[i] = arguments.callee(obj[i]);
            }
            return out;
        }
        return obj;
    }


    function loadAndDisplayPageRankNodesWithValue(numberOfDisplayNodes, loadDefaultValuesInOptionsCallback, loadAndDisplayPageRankNodesWithValueCallback) {
        //Did we already load data from input file?
        if (inputLinksFromFile.length == 0) {
            d3.csv(inputFileName, function (error, links) {
                //Cache for storing all values from file. We will use this only once and for subsequent uses, value will be taken from this array
                inputLinksFromFile = links;
                maximumNumberOfLinksFromFile = inputLinksFromFile.length;

                //Show Default number of links on screen. Default is 10
                loadDefaultValuesInOptionsCallback();
                loadAndDisplayPageRankNodesWithValueCallback();
                loadAllLinkValuesFromStoredArray(numberOfDisplayNodes);
            });
        }
        else {
            loadAllLinkValuesFromStoredArray(numberOfDisplayNodes);
        }
    }


    function loadAllLinkValuesFromStoredArray(numberOfLinksToDisplay) {

        //If somehow number of input links to display parameter value is more than maximum number of links in a file
        //Adjust it to maximum number of nodes
        if (numberOfLinksToDisplay > maximumNumberOfLinksFromFile) {
            numberOfLinksToDisplay = maximumNumberOfLinksFromFile;
        }

        //Deep clone the array
        var tempNodes = clone(inputLinksFromFile);
        console.log("Range of nodes extracted from file is Minimum 0 to maximum " + (numberOfLinksToDisplay - 1))
        drawGraphwithInputLinks(tempNodes.slice(0, (numberOfLinksToDisplay)));
    }
    function configureOptionsAndInstructionsView() {
        d3.select("body")
            .append("p")
            .attr("id", "mainParagraph")
            .style("width", width)
            .attr("class", "instructionsView")
            .on("mousedown", function () {
                    d3.event.stopPropagation();
                }
            );

        var select = d3.select("p")
            .append("p")
            .attr("id", "options")
            .attr("class", "optionsParagraph")
            .text("Number Of links to show")
            .style("line-height", "60px")
            .append("select")
            .attr("class", "optionsBox")
            .on("change", numberOfNodesOptionChanged);

        var options = select.selectAll('option')
            .data(numberOfNodesOptions);

        options.enter().append("option").text(function (numberOfNodesValue) {
            return numberOfNodesValue;
        });
        d3.select("p#options").append("button")
            .text("Multiple Div View")
            .attr("class", "mouseOut selectionButton")
            .on('mouseover', function () {
                d3.select(this).classed({"mouseOut": false, "mouseIn": true});
            })
            .on('mouseout', function () {
                d3.select(this).classed({"mouseOut": true, "mouseIn": false});
            })
            .on('click', function (d, i) {

                if (!isDrawingWithSingleView) {
                    console.log("Removing all elemnts");
                    d3.select(this).text("Multiple Div View");
                    removeAllSVGElements();
//                loadAndDisplayPageRankNodesWithValue(10, loadDefaultValuesInOptions,configureOptionsAndInstructionsView);
                }
                else {
                    d3.select(this).text("Single Div View");
                }
                isDrawingWithSingleView = !isDrawingWithSingleView;

            });

        d3.select("p").append("p").attr("class", "spacing");

    }

    function numberOfNodesOptionChanged() {
        var selectenumberOfLinksToDisplayValue = +(d3.select(this).property('value'));
        loadAndDisplayPageRankNodesWithValue(selectenumberOfLinksToDisplayValue);
    }

    function drawGraphwithInputLinks(links) {

        // Compute the Distinct nodes from the link
        var totalnumberOfLinksToDisplay = links.length;
        var heightScalingFactor = (totalnumberOfLinksToDisplay > 30) ? 20 : 35;
        height = heightScalingFactor * totalnumberOfLinksToDisplay;

        var maximumPossibleWidth = 10 * totalnumberOfLinksToDisplay;
        if (maximumPossibleWidth > width) {
            width = maximumPossibleWidth;
        }
        var path, markerPath, node;
        var nodes = {};

        links.forEach(function (link) {
            link.source = nodes[link.source] ||
                (nodes[link.source] = {name: link.source, radiusValue: link.value});
            link.target = nodes[link.target] ||
                (nodes[link.target] = {name: link.target});
            link.value = +link.value;
            link.source.radiusValue = link.value;
        });

        //We don't want to expand nodes beyond certain acceptable range of radius
        //Domain will include both negative and positive values. Value of individual node will depend on significance of
        //Each node in given graph
        radiusScale = d3.scale.linear()
            .domain([d3.min(links, function (link) {
                return link.value;
            }), d3.max(links, function (link) {
                return link.value;
            })])
            .range([3, maximumRadiusValue]);


        if (isDrawingWithSingleView) {
            console.log("Removing All Elements");
            removeAllSVGElements();
        }

        var svg = d3.select("p").append("svg")
            .attr("id", "id" + SVGElementSequenceNumber)
            .style("opacity", 0);

        svg.transition()
            .duration(defaultAnimationDuration)
            .style("opacity", 1)
            .attr("width", width)
            .attr("height", height);

        svg.append("rect")
            .attr("width", "100%")
            .attr("height", "100%")
            .attr("class", "sam")
            .attr("fill", function () {
                return color(links.length % 20);
            });
        SVGElementSequenceNumber++;
        var force = d3.layout.force()
            .nodes(d3.values(nodes))
            .links(links)
            .size([width, height])
            .linkDistance(7 * totalnumberOfLinksToDisplay)
            .charge(-400)
            .on("tick", function () {
                tick(node, path, markerPath);
            })
            .start();
        // build the arrow.
        svg.append("svg:defs").selectAll("marker")
            .data(["end"])
            .enter().append("svg:marker")
            .attr("id", String)
            .attr("viewBox", "0 -5 10 10")
            .attr("refX", -1.5)
            .attr("refY", -1.5)
            .attr("markerWidth", 6)
            .attr("markerHeight", 6)
            .attr("orient", "auto")
            .append("svg:path")
            .attr("d", "M0,-5L10,0L0,5");
        // add the links and the arrows
        linksCollection = force.links();
        nodesCollection = force.nodes();
        path = svg.append("svg:g").selectAll("path.link")
            .data(linksCollection)
            .enter().append("svg:path")
            .attr("class", "link");

        //This code is added to make arrow heads appearing in the middle of curve connecting two nodes
        markerPath = svg.append("svg:g").selectAll("path.marker")
            .data(linksCollection)
            .enter().append("svg:path")
            .attr("class", "marker_only")
            .attr("marker-end", "url(#end)");
        //Define the nodes
        node = svg.selectAll(".node")
            .data(nodesCollection)
            .enter().append("g")
            .attr("class", "node")
            .call(force.drag);
        //Add the nodes
        node.append("circle")
            .attr("r", function (node) {
                return getRadiusValueForNode(node);
            })
            .style("fill", function (node, index) {
                return color(index);
            });
        node.on("mousedown", function () {
            d3.event.stopPropagation();
        })
        node.on("mouseover", function (d) {
            d3.select(this).classed("node-active", true);
            var radiusForCurrentNode = getRadiusValueForNode(d);
            d3.select(this).select("circle").transition()
                .duration(750)
                .attr("r", radiusForCurrentNode * 2);
        });
        node.on("mouseout", function (d) {
            node.classed("node-active", false);

            var radiusForCurrentNode = getRadiusValueForNode(d);
            d3.select(this)
                .select("circle").transition()
                .duration(200)
                .attr("r", radiusForCurrentNode);
        });

        // add the text
        node.append("svg:text")
            .attr("x", "-0.5em")
            .attr("y", function (d) {
                if (typeof d.radiusValue === "undefined" || d.radiusValue == minimumRadiusValue || d.radiusValue == 0) {
                    return "-0.90em"
                }
                else {
                    return "0.31em";
                }
            })
            .style("font-size", "14px")
            .text(function (d) {
                return d.name;
            });

        var $target = $('html,body');
        var finalDocumentHeight = $(document).height();

        if (SVGElementSequenceNumber > 2) {
            //Whenver we have more than one elements we will scroll to very bottom and then scroll up with value equal
            //To height of latest svg elements embedded to the body
            var lastSVGElement = d3.select("svg#id" + (SVGElementSequenceNumber - 1));
            console.log("current elements id " + (SVGElementSequenceNumber - 1));
            $target.animate({scrollTop: finalDocumentHeight - (lastSVGElement.attr("height"))}, defaultAnimationDuration / 2);
        }
        else {
            //In case there is only one div element in the body, we will scroll to the position which is half the total height of
            $target.animate({scrollTop: finalDocumentHeight / 2}, defaultAnimationDuration / 2);
        }
        d3.select("body")
            .on("mousedown", function () {
                mousedown(force);
            });
    }

    function loadDefaultValuesInOptions() {
        console.log("Max number of nodes " + maximumNumberOfLinksFromFile);
        var tempnumberOfLinksToDisplay = numberOfLinksToDisplay;
        while (tempnumberOfLinksToDisplay <= maximumNumberOfLinksFromFile) {
            numberOfNodesOptions.push(tempnumberOfLinksToDisplay);
            tempnumberOfLinksToDisplay += 10;
        }
        if ((tempnumberOfLinksToDisplay - maximumNumberOfLinksFromFile) > 0) {
            numberOfNodesOptions.push(maximumNumberOfLinksFromFile);
        }
    }

    function getRadiusValueForNode(node) {
        var radiusForCurrentNode = 0;
        if (typeof node.radiusValue !== "undefined") {
            radiusForCurrentNode = radiusScale(node.radiusValue);
        }
        else {
            radiusForCurrentNode = radiusScale(0);
        }
        return radiusForCurrentNode;
    }

    function mousedown(force) {
        //Create a fancy event when mouse is clicked anywhere in
        nodesCollection.forEach(function (node, index) {
            node.x += (Math.random() - 0.5) * 100;
            node.y += (Math.random() - 0.5) * 100;
        });
        force.resume();
    }

    function removeAllSVGElements() {
        var currentSVGSequenceNumber = 1;
        var allSVGElements = d3.select("svg");
        if (typeof allSVGElements !== "undefined") {
            if (d3.selectAll("svg")[0].length > 1) {
                while (currentSVGSequenceNumber < (SVGElementSequenceNumber - 1)) {
                    console.log("Removing sequence number " + currentSVGSequenceNumber);

                    d3.select("svg#id" + currentSVGSequenceNumber)
                        .transition()
                        .duration(defaultAnimationDuration)
                        .style("opacity", 0)
                        .attr("height", 0)
                        .remove();


                    currentSVGSequenceNumber++;
                }
            }
            else {
                allSVGElements.remove();
                SVGElementSequenceNumber = 1;
            }
        }
    }

    function tick(node, path, markerPath) {
        //To adjust links connecting two nodes
        path.attr("d", function (d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            return "M" +
                d.source.x + "," +
                d.source.y + "A" +
                dr + "," + dr + " 0 0,1 " +
                d.target.x + "," +
                d.target.y;
        });

        //To adjust arrow heads on connecting links which appear to be present
        //In the middle
        markerPath.attr("d", function (d) {
            var dx = d.target.x - d.source.x,
                dy = d.target.y - d.source.y,
                dr = Math.sqrt(dx * dx + dy * dy);
            // We know the center of the arc will be some distance perpendicular from the
            // link segment's midpoint. The midpoint is computed as:
            var endX = (d.target.x + d.source.x) / 2;
            var endY = (d.target.y + d.source.y) / 2;
            // Notice that the paths are the arcs generated by a circle whose
            // radius is the same as the distance between the nodes. This simplifies the
            // trig as we can simply apply the 30-60-90 triangle rule to find the difference
            // between the radius and the distance to the segment midpoint from the circle
            // center.
            var len = dr - ((dr / 2) * Math.sqrt(3));

            // Remember that is we have a line's slope then the perpendicular slope is the
            // negative inverse.
            endX = endX + (dy * len / dr);
            endY = endY + (-dx * len / dr);

            return "M" + d.source.x + "," + d.source.y + "A" + dr + "," + dr + " 0 0,1 " + endX + "," + endY;
        });
        //How much each node should translate when graph is played with
        node.attr("transform", function (d) {
            return "translate(" + d.x + "," + d.y + ")";
        });

    }
</script>
</body>
</html>